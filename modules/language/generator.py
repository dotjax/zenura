import random

def sample_from_distribution(distribution, temperature=1.0):
    """
    Sample a key from a dict {value: count} probabilistically,
    applying temperature for randomness control.
    """
    if not distribution:
        return None

    # Convert counts to probabilities
    values, counts = zip(*distribution.items())

    # Apply temperature
    adjusted_counts = [count ** (1.0 / temperature) for count in counts]
    total = sum(adjusted_counts)
    if total == 0:
        return random.choice(values) # Fallback if all adjusted counts are zero
    probabilities = [count / total for count in adjusted_counts]

    # Sample according to probabilities
    chosen = random.choices(values, weights=probabilities, k=1)[0]
    return chosen

def generate_response(memory, start_byte=None, max_length=100, temperature=1.0):
    """
    Generate a byte sequence from learned memory.
    """
    if not memory:
        return []

    # Get all known keys to choose from
    all_keys = list(memory.keys())
    
    # Pick a starting context
    if start_byte is not None:
        # Find all keys that start with the desired byte
        possible_starts = [k for k in all_keys if k[0] == start_byte]
        if possible_starts:
            context = random.choice(possible_starts)
        else:
            context = random.choice(all_keys) # Fallback to random if no match
    else:
        context = random.choice(all_keys)

    # Initialize the generated sequence with the first byte of the context
    generated = [context[0]]

    for _ in range(max_length - 1):
        # Find what bytes can follow the current context
        next_options = memory.get(context)
        if not next_options:
            break # Dead end

        # Sample the next byte
        next_byte = sample_from_distribution(next_options, temperature)
        if next_byte is None:
            break # Sampling failed
        
        generated.append(next_byte)

        # To continue, find all known contexts that START with our newly generated byte
        possible_next_contexts = [k for k in all_keys if k[0] == next_byte]
        
        if not possible_next_contexts:
            break # Dead end, nowhere to go from this byte

        # Pick one of the possible next contexts at random to continue the chain
        context = random.choice(possible_next_contexts)

    return generated